\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  AC & Anticipated Change\\
  DAG & Directed Acyclic Graph \\
  M & Module \\
  MG & Module Guide \\
  OS & Operating System \\
  R & Requirement\\
  SC & Scientific Computing \\
  SRS & Software Requirements Specification\\
  \progname & Explanation of program name\\
  UC & Unlikely Change \\
  \wss{etc.} & \wss{...}\\
  \bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing
software.  A module is a work assignment for a programmer or programming
team~\citep{ParnasEtAl1984}.  We advocate a decomposition
based on the principle of information hiding~\citep{Parnas1972a}.  This
principle supports design for change, because the ``secrets'' that each module
hides represent likely future changes.  Design for change is valuable in SC,
where modifications are frequent, especially during initial development as the
solution space is explored.  

Our design follows the rules layed out by \citet{ParnasEtAl1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the
  secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\citep{ParnasEtAl1984}. The MG
specifies the modular structure of the system and is intended to allow both
designers and maintainers to easily identify the parts of the software.  The
potential readers of this document are as follows:

\begin{itemize}
\item New project members: This document can be a guide for a new project member
  to easily understand the overall structure and quickly find the
  relevant modules they are searching for.
\item Maintainers: The hierarchical structure of the module guide improves the
  maintainers' understanding when they need to make changes to the system. It is
  important for a maintainer to update the relevant sections of the document
  after changes have been made.
\item Designers: Once the module guide has been written, it can be used to
  check for consistency, feasibility, and flexibility. Designers can verify the
  system in various ways, such as consistency among modules, feasibility of the
  decomposition, and flexibility of the design.
\end{itemize}

The rest of the document is organized as follows. Section
\ref{SecChange} lists the anticipated and unlikely changes of the software
requirements. Section \ref{SecMH} summarizes the module decomposition that
was constructed according to the likely changes. Section \ref{SecConnection}
specifies the connections between the software requirements and the
modules. Section \ref{SecMD} gives a detailed description of the
modules. Section \ref{SecTM} includes two traceability matrices. One checks
the completeness of the design against the requirements provided in the SRS. The
other shows the relation between anticipated changes and the modules. Section
\ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system. According to the likeliness
of the change, the possible changes are classified into two
categories. Anticipated changes are listed in Section \ref{SecAchange}, and
unlikely changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. The approach
adapted here is called design for
change.

\begin{description}
\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific
  hardware on which the software is running.
\item[\refstepcounter{acnum} \actheacnum \label{acInput}:] The format of the
  initial input data.
\item[\refstepcounter{acnum} \actheacnum \label{acAudioGen}:] The method of 
  generating simulated microphone array input for testing and proof of concept.
\end{description}

\wss{Anticipated changes relate to changes that would be made in requirements,
design or implementation choices.  They are not related to changes that are made
at run-time, like the values of parameters.}

\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible. However, a general system is
more complex. Sometimes this complexity is not necessary. Fixing some design
decisions at the system architecture stage can simplify the software design. If
these decision should later need to be changed, then many parts of the design
will potentially need to be modified. Hence, it is not intended that these
decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum \label{ucIO}:] Input/Output devices
  (Input: File and/or Keyboard, Output: File, Memory, and/or Screen).
\item ...
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design. Modules are summarized
in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed
below, which are leaves in the hierarchy tree, are the modules that will
actually be implemented.

\begin{description}
\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module
\item [\refstepcounter{mnum} \mthemnum \label{mAudioGen}:] Audio Generation Module
\item [\refstepcounter{mnum} \mthemnum \label{mDOA}:] DOA Processor Module
\end{description}


\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Audio Generation Module\\
& DOA Processor Module\\
& ?\\
& ?\\
& ?\\
& ?\\
& ?\\ 
& ?\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} & {?}\\
& ?\\
& ?\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in
the SRS. In this stage, the system is decomposed into modules. The connection
between requirements and modules is listed in Table~\ref{TblRT}.

\wss{The intention of this section is to document decisions that are made
  ``between'' the requirements and the design.  To satisfy some requirements,
  design decisions need to be made.  Rather than make these decisions implicit,
  they are explicitly recorded here.  For instance, if a program has security
  requirements, a specific design decision may be made to satisfy those
  requirements with a password.}

\section{Module Decomposition} \label{SecMD}

Modules are decomposed according to the principle of ``information hiding''
proposed by \citet{ParnasEtAl1984}. The \emph{Secrets} field in a module
decomposition is a brief statement of the design decision hidden by the
module. The \emph{Services} field specifies \emph{what} the module will do
without documenting \emph{how} to do it. For each module, a suggestion for the
implementing software is given under the \emph{Implemented By} title. If the
entry is \emph{OS}, this means that the module is provided by the operating
system or by standard programming language libraries.  \emph{\progname{}} means the
module will be implemented by the \progname{} software.

Only the leaf modules in the hierarchy have to be implemented. If a dash
(\emph{--}) is shown, this means that the module is not a leaf and will not have
to be implemented.

\subsection{Hardware Hiding Modules (\mref{mHH})}

\begin{description}
\item[Secrets:]The data structure and algorithm used to implement the virtual
  hardware.
\item[Services:]Serves as a virtual hardware used by the rest of the
  system. This module provides the interface between the hardware and the
  software. So, the system can use it to display outputs or to accept inputs.
\item[Implemented By:] OS
\end{description}

\subsection{Behaviour-Hiding Module}

\begin{description}
\item[Secrets:]The contents of the required behaviours.
\item[Services:]Includes programs that provide externally visible behaviour of
  the system as specified in the software requirements specification (SRS)
  documents. This module serves as a communication layer between the
  hardware-hiding module and the software decision module. The programs in this
  module will need to change if there are changes in the SRS.
\item[Implemented By:] --
\end{description}

\subsubsection{Audio Generation Module (\mref{mAudioGen})}

\begin{description}
\item[Secrets:] The algorithm for simulating room acoustics and generating 
  synthetic microphone array data from a given audio source and position. This 
  includes room response calculations and spatial audio propagation 
  models. 
\item[Services:] Provides simulated four-channel microphone array output for 
  testing and proof-of-concept development. Takes as input an audio source 
  signal and 3D position coordinates, and outputs four synchronized audio 
  streams representing what each microphone in the array would capture given 
  the room acoustics and source location.
\item[Implemented By:] Python using pyroomacoustics library
\item[Type of Module:] Library
\item[Notes:] This module is temporary and intended only for proof-of-concept 
  development. It will be removed in the final product once physical hardware 
  microphones are integrated. The module enables algorithm development and 
  testing without requiring the complete hardware setup.
\end{description}

\subsubsection{DOA Processor Module (\mref{mDOA})}

\begin{description}
\item[Secrets:] The specific direction of arrival estimation algorithm and its 
  implementation details, including signal processing techniques (MUSIC, 
  SRP-PHAT, or FRIDA), frequency analysis methods, and coordinate system 
  transformations.
\item[Services:] Analyzes four synchronized microphone audio streams to estimate 
  the direction of arrival of a sound source. Takes as input four time-domain or 
  frequency-domain audio signals and outputs an angle (in degrees) representing 
  the estimated direction of the sound source relative to the microphone array's 
  reference axis. Provides real-time directional audio analysis with target 
  accuracy of 45 degrees as specified in the SRS (\hyperref[NFR5_3]{NFR5.3}).
\item[Implemented By:] \progname{} (Python for prototyping, C/C++ for embedded 
  implementation)
\item[Type of Module:] Abstract Data Type
\item[Notes:] This module is core to the system's primary functionality of 
  providing directional awareness. It implements one or more DOA algorithms and 
  may include algorithm selection logic based on environmental conditions or 
  computational constraints. Ideally, there should be no changes to this module
  for the final product aside from the internal implementation details 
  (programming language for efficiency and combatilibility).
\end{description}

\subsubsection{Etc.}


\subsection{Software Decision Module}

\begin{description}
\item[Secrets:] The design decision based on mathematical theorems, physical
  facts, or programming considerations. The secrets of this module are
  \emph{not} described in the SRS.
\item[Services:] Includes data structure and algorithms used in the system that
  do not provide direct interaction with the user. 
  % Changes in these modules are more likely to be motivated by a desire to
  % improve performance than by externally imposed changes.
\item[Implemented By:] --
\end{description}

\subsubsection{Etc.}

\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

\subsection{Modules to Requirements Traceability}

The following table maps each module to the functional and non-functional 
requirements from the SRS that it helps satisfy. Requirements are referenced 
using the labels defined in the SRS document.

\begin{table}[H]
\centering
\begin{tabular}{p{0.25\textwidth} p{0.65\textwidth}}
\toprule
\textbf{Module} & \textbf{Requirements}\\
\midrule
\mref{mAudioGen} & Testing support for FR1.2, FR5.2, FR7.1, FR7.2, NFR7.1\\
\midrule
\mref{mDOA} & FR5.2, FR5.3, NFR5.3\\
\bottomrule
\end{tabular}
\caption{Trace Between Modules and SRS Requirements}
\label{TblMR}
\end{table}

\noindent
\textbf{Explanation of Module-Requirement Mappings:}

\begin{itemize}
\item \textbf{Audio Generation Module (\mref{mAudioGen}):} This module is used 
exclusively for testing and proof-of-concept development. It enables validation 
of requirements related to microphone synchronization (FR1.2), direction of 
arrival estimation (FR5.2), and audio capture specifications (FR7.1, FR7.2, 
NFR7.1) without requiring complete hardware integration.

\item \textbf{DOA Processor Module (\mref{mDOA}):} This module directly 
implements the core direction of arrival functionality specified in the SRS:
  \begin{itemize}
  \item FR5.2 - Direction of arrival estimation from frequency domain audio
  \item FR5.3 - Angular representation of sound source direction
  \item NFR5.3 - Maximum 45° error in direction estimation accuracy
  \end{itemize}
\end{itemize}

\subsection{Modules to Anticipated Changes Traceability}

The following table maps anticipated changes to the modules that would need to 
be modified if those changes occur. This supports the principle of information 
hiding by showing which design decisions are localized to specific modules.

\begin{table}[H]
\centering
\begin{tabular}{p{0.25\textwidth} p{0.65\textwidth}}
\toprule
\textbf{AC} & \textbf{Modules}\\
\midrule
\acref{acAudioGen} & \mref{mAudioGen}\\
\bottomrule
\end{tabular}
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\end{table}

\noindent
\textbf{Explanation of Anticipated Change Mappings:}

\begin{itemize}
\item \textbf{\acref{acAudioGen} - Audio generation method:} Changes to the 
simulation approach, room acoustics model, or testing methodology would only 
affect the Audio Generation Module. Since this module is temporary and isolated 
from the production system, it can be modified or removed without impacting other 
modules. The final product will replace this module entirely with hardware 
microphone drivers.

\end{itemize}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is
provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if
correct execution of B may be necessary for A to complete the task described in
its specification. That is, A {\em uses} B if there exist situations in which
the correct functioning of A depends upon the availability of a correct
implementation of B.  Figure \ref{FigUH} illustrates the use relation between
the modules. It can be seen that the graph is a directed acyclic graph
(DAG). Each level of the hierarchy offers a testable and usable subset of the
system, and modules in the higher level of the hierarchy are essentially simpler
because they use modules from the lower levels.

\wss{The uses relation is not a data flow diagram.  In the code there will often
be an import statement in module A when it directly uses module B.  Module B
provides the services that module A needs.  The code for module A needs to be
able to see these services (hence the import statement).  Since the uses
relation is transitive, there is a use relation without an import, but the
arrows in the diagram typically correspond to the presence of import statement.}

\wss{If module A uses module B, the arrow is directed from A to B.}

\subsection{Use Relationships for Audio Generation and DOA Processor Modules}

The following describes the use relationships for the two modules being 
documented:

\subsubsection{Audio Generation Module (\mref{mAudioGen}) Dependencies}

\textbf{Modules Used By Audio Generation Module:}
\begin{itemize}
\item \textbf{Hardware-Hiding Module (\mref{mHH}):} The Audio Generation Module 
uses the Hardware-Hiding Module to access file I/O services for reading source 
audio files and writing generated microphone array outputs. This dependency 
ensures the module can operate across different platforms without modification.

\item \textbf{Python Standard Libraries:} For numerical computation (NumPy), 
audio processing (SciPy), and room acoustics simulation (pyroomacoustics). These 
are external dependencies that provide the mathematical foundations for the 
simulation.
\end{itemize}

\textbf{Modules That Use Audio Generation Module:}
\begin{itemize}
\item \textbf{DOA Processor Module (\mref{mDOA}):} During testing and 
proof-of-concept development, the DOA Processor uses the Audio Generation Module 
to obtain synthetic four-channel microphone data for algorithm validation.

\item \textbf{Testing Framework:} Automated tests use this module to generate 
controlled audio scenarios with known ground truth for validation of the entire 
signal processing pipeline.
\end{itemize}

\subsubsection{DOA Processor Module (\mref{mDOA}) Dependencies}

\textbf{Modules Used By DOA Processor Module:}
\begin{itemize}
\item \textbf{Audio Filtering Module:} The DOA Processor uses the Audio Filtering 
Module to obtain frequency-domain representations of the four microphone signals. 
The filtering module provides FFT-transformed, normalized, and noise-filtered 
audio data that is suitable for DOA algorithms.

\item \textbf{Audio Generation Module:} The DOA Processor uses the Audio 
Generation Module to obtain the four microphone signals. 
The audio generation module provides the four microphone signals that are 
suitable for DOA algorithms. Note, as mentioned previosuly, this module 
dependency is expected to be removed for the final product.

\item \textbf{Mathematical Libraries:} Uses linear algebra and signal processing 
libraries for matrix operations, FFT/IFFT, and statistical computations required 
by DOA algorithms.
\end{itemize}

\textbf{Modules That Use DOA Processor Module:}
\begin{itemize}
\item \textbf{Visualization Module:} Uses the DOA Processor's output 
(direction angle in degrees) to generate visual indicators on the display 
showing the user where sound sources are located.
\end{itemize}

\begin{figure}[H]
\centering
%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
\caption{Use hierarchy among modules}
\label{FigUH}
\end{figure}

%\section*{References}

\section{User Interfaces}

\wss{[Design of user interface for software and hardware. Attach an appendix if needed. Drawings,
Sketches, Figma —SS]}

\section{Design of Communication Protocols}

\wss{If appropriate}

\section{Timeline}

\wss{Schedule of tasks and who is responsible}

\wss{You can point to GitHub if this information is included there}

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage{}

\end{document}